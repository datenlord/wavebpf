package wavebpf

import spinal.core._
import spinal.sim._
import spinal.core.sim._
import scala.util.Random

import org.scalatest.funsuite.AnyFunSuite

class SimIndirectSortSpec extends AnyFunSuite {
  // tests go here...
  test("SimIndirectSort") {
    import SimUtil._

    val program =
      Array[Short](
        0x85, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x67, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xb7, 0x02, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xbf, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x01, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x79, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xb7, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7b, 0x1a, 0xf8, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x6d, 0x12, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x67, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x79, 0x05, 0x18, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x79, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xb7, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x7b, 0x1a, 0xe8, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x79, 0xa6, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x7b, 0x6a, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x07, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x79, 0xa1, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x14, 0x1c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xbf, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xa7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x79, 0xa7, 0xf8, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xb7, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x71, 0xf6, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xb7, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x79, 0xa8, 0xe8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x1d, 0x76, 0xf1, 0xff, 0x00, 0x00, 0x00, 0x00, 0x79, 0x89, 0xf8, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x79, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xbf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0xbf, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x90, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0xbf, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x79, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x22, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7d, 0x12, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x7b, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x38, 0xf8, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0xed, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      ).map(_.toByte)

    def runOnce(
        dut: CustomWbpf,
        coreIndices: Seq[Int],
        indiceGroups: Seq[Seq[Long]],
        values: Seq[Long]
    ) = {
      assert(coreIndices.length == indiceGroups.length)
      assert(indiceGroups.forall(indices => indices.length == values.length))
      println(
        "Running program on core " + coreIndices.mkString(
          ", "
        ) + " - data size: " + indiceGroups(0).length
      )
      dmWriteOnce(dut, 0x08, values.length)

      val dataBaseAddr = 0x50L
      var addr = dataBaseAddr

      for (value <- values) {
        dmWriteOnce(dut, addr, value)
        addr += 8
      }

      var controlBaseAddr = 0x10L

      val indicesBaseAddrs = indiceGroups
        .zip(coreIndices)
        .map(arg => {
          val (indices, coreIndex) = arg
          dmWriteOnce(dut, controlBaseAddr + 16 * coreIndex, addr)
          dmWriteOnce(dut, controlBaseAddr + 16 * coreIndex + 8, dataBaseAddr)
          val base = addr
          for (indice <- indices) {
            dmWriteOnce(dut, addr, indice)
            addr += 8
          }
          base
        })
      for (ci <- coreIndices) {
        assert(dut.io.excOutput(ci).valid.toBoolean)
        mmioWrite(dut, 0x18 + 0x1000 * (ci + 1), 0x00)
      }
      resetPerfCounters(dut, 0)

      dut.clockDomain.waitSamplingWhere(
        !coreIndices.exists(i => dut.io.excOutput(i).valid.toBoolean)
      )

      var cycleCount = 0
      while (coreIndices.exists(i => !dut.io.excOutput(i).valid.toBoolean)) {
        dut.clockDomain.waitSampling()
        cycleCount += 1
      }

      for (ci <- coreIndices) {
        if (dut.io.excOutput(ci).code.toEnum != CpuExceptionCode.EXIT) {
          throw new Exception(
            "Exception on core " + ci + " - " + dut.io.excOutput(ci).code.toEnum
          )
        }
      }
      println("Cycle count: " + cycleCount)
      printPerfCounters(dut, 0)

      for ((indices, baseAddr) <- indiceGroups.zip(indicesBaseAddrs)) {
        val sortedIndices =
          indices.sortBy(x => values(x.toInt))
        var addr = baseAddr
        for (indice <- sortedIndices) {
          val value = dmReadOnce(dut, addr)
          assert(
            value == indice,
            "Indice " + indice + " at addr " + addr + " mismatch"
          )
          addr += 8
        }
      }
      println("Validation OK")
    }

    def runOnceRandom(dut: CustomWbpf, coreIndices: Seq[Int], dataSize: Int) = {
      val indices = coreIndices.map(i =>
        Random.shuffle((0 until dataSize).toList).toSeq.map(_.toLong)
      )
      val values = (0 until dataSize).map(x => Random.nextInt(1000).toLong)
      runOnce(dut, coreIndices, indices, values)
    }

    val config = DefaultWbpfConfig()
    runWithAllConfig { dut =>
      initDutForTesting(dut)

      val firstExc = dut.io.excOutput.head

      for (i <- 0 until 4) {
        loadCode(dut, i, 0x0, program)
      }
      println("Code loaded.")

      runOnce(dut, Seq(0), Seq(Seq(0, 1, 2, 3)), Seq(42, 1, 3, 9))
      runOnceRandom(dut, Seq(0), 50)
      runOnceRandom(dut, Seq(1), 50)
      runOnceRandom(dut, Seq(0, 1), 50)
      runOnceRandom(dut, Seq(0, 1, 2, 3), 50)
    }
  }
}
