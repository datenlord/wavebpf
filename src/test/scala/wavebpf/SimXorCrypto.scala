package wavebpf

import spinal.core._
import spinal.sim._
import spinal.core.sim._
import scala.util.Random

import org.scalatest.funsuite.AnyFunSuite

class SimXorCryptoSpec extends AnyFunSuite {
  // tests go here...
  test("SimXorCrypto") {
    import SimUtil._
    val config = DefaultWbpfConfig()
    SimConfig.withWave.doSim(
      new CustomWbpf(config.copy(pe = config.pe.copy(reportCommit = false)))
    ) { dut =>
      initDutForTesting(dut)

      val firstExc = dut.io.excOutput.head

      loadCode(
        dut,
        0,
        0x0,
        Array[Short](
          0xb7, 0x01, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x79, 0x11, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x02, 0x00, 0x00, 0x01, 0x00,
          0x00, 0x00, 0x6d, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7,
          0x02, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x79, 0x22, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0xb7, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00,
          0x00, 0x79, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x04,
          0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x79, 0x44, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0xb7, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x05, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x36, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x56, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x71, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71,
          0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x65, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x73, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x07, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x01,
          0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x05, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x55, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
          0xb7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x56, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x07, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb7,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x26, 0xf0, 0xff,
          0x00, 0x00, 0x00, 0x00, 0xbf, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x05, 0x00, 0xee, 0xff, 0x00, 0x00, 0x00, 0x00
        ).map(_.toByte)
      )
      println("Code loaded.")

      val dataAddr = 0x100
      val dataSize = 64
      val keyAddr = 0x90
      val keySize = 10
      dmWriteOnce(dut, 0x10, dataAddr)
      dmWriteOnce(dut, 0x18, dataSize)
      dmWriteOnce(dut, 0x20, keyAddr)
      dmWriteOnce(dut, 0x28, keySize)

      val dataBuf = (0 until dataSize).map(i => Random.nextInt(256))
      val keyBuf = (0 until keySize).map(i => Random.nextInt(256))

      for (i <- 0 until dataSize) {
        dmWriteOnce(dut, dataAddr + i, dataBuf(i), MemoryAccessWidth.W1)
      }
      for (i <- 0 until keySize) {
        dmWriteOnce(dut, keyAddr + i, keyBuf(i), MemoryAccessWidth.W1)
      }
      for (i <- 0 until dataSize) {
        assert(
          dmReadOnce(dut, dataAddr + i, MemoryAccessWidth.W1) == dataBuf(i)
        )
      }

      assert(firstExc.valid.toBoolean)
      assert(firstExc.code.toEnum == CpuExceptionCode.NOT_INIT)

      mmioWrite(dut, 0x1018, 0x00)
      dut.clockDomain.waitSamplingWhere(!firstExc.valid.toBoolean)
      dut.clockDomain.waitSamplingWhere(firstExc.valid.toBoolean)
      assert(firstExc.code.toEnum == CpuExceptionCode.EXIT)

      for (i <- 0 until dataSize) {
        val expected = dataBuf(i) ^ keyBuf(i % keySize)
        val actual = dmReadOnce(dut, dataAddr + i, MemoryAccessWidth.W1)
        assert(
          actual == expected,
          "data mismatch at index " + i + " " + dataBuf(i) + " " + keyBuf(
            i % keySize
          )
        )
      }
      println("Check passed.")
    }
  }
}
